#!/usr/bin/env python3
"""
Memory Snapshot Analysis Tool for PyTorch CUDA Memory Debugging

This script analyzes memory snapshots generated by the FSDP memory debugging feature.
Usage: python analyze_memory_snapshot.py <path_to_pickle_file>
"""

import torch
import pickle
import sys
import os
from collections import defaultdict


def analyze_memory_snapshot(file_path):
    """Analyze a PyTorch memory snapshot pickle file."""
    if not os.path.exists(file_path):
        print(f"‚ùå File not found: {file_path}")
        return
    
    try:
        print(f"üìÇ Loading snapshot from: {file_path}")
        with open(file_path, 'rb') as f:
            snapshot = pickle.load(f)
        
        print(f"üìÇ Analyzing: {os.path.basename(file_path)}")
        
        # Only handle dict-based snapshots with segments
        if isinstance(snapshot, dict) and 'segments' in snapshot:
            segments = snapshot['segments']
            print(f"üîç Memory segments: {len(segments)} segments")
            
            # Show only segments with significant allocation (>1MB)
            total_allocated = 0
            active_segments = 0
            
            for i, segment in enumerate(segments):
                if isinstance(segment, dict):
                    allocated_size = segment.get('allocated_size', 0)
                    if allocated_size > 1024*1024:  # Only show >1MB allocations
                        print(f"  Segment {i}: {allocated_size/(1024**2):.2f}MB allocated")
                    total_allocated += allocated_size
                    if allocated_size > 0:
                        active_segments += 1
            
            # Get peak memory from device traces
            peak_memory = 0
            if 'device_traces' in snapshot:
                device_traces = snapshot['device_traces']
                for device_trace in device_traces:
                    if isinstance(device_trace, list):
                        for trace in device_trace:
                            if isinstance(trace, dict) and 'size' in trace:
                                peak_memory = max(peak_memory, trace['size'])
            
            print(f"\nüìä Summary:")
            print(f"  üî• Total Allocated: {total_allocated/(1024**3):.2f} GB")
            print(f"  üìà Active Segments: {active_segments}/{len(segments)}")
            if peak_memory > 0:
                print(f"  üéØ Peak Memory: {peak_memory/(1024**3):.2f} GB")
        else:
            print("‚ùå No memory segments found in snapshot")
        
        print("-" * 50)
        
    except Exception as e:
        print(f"‚ùå Error analyzing snapshot: {e}")
        import traceback
        traceback.print_exc()


def analyze_directory(dir_path):
    """Analyze all pickle files in a directory."""
    if not os.path.exists(dir_path):
        print(f"‚ùå Directory not found: {dir_path}")
        return
    
    pickle_files = []
    for root, dirs, files in os.walk(dir_path):
        for file in files:
            if file.endswith('.pickle'):
                pickle_files.append(os.path.join(root, file))
    
    if not pickle_files:
        print(f"‚ùå No pickle files found in: {dir_path}")
        return
    
    print(f"üîç Found {len(pickle_files)} pickle files in {dir_path}")
    
    # Sort files and get the last one.
    sorted_files = sorted(pickle_files)
    last_file = sorted_files[-1]

    
    print(f"üìã Analyzing the most recent file:")
    print(f"\n{'='*80}")
    print(f"üìÅ Most recent file: {os.path.basename(last_file)}")
    print(f"üìÅ Full path: {last_file}")
    print(f"{'='*80}")
    analyze_memory_snapshot(last_file)


def main():
    if len(sys.argv) != 2:
        print("Usage: python analyze_memory_snapshot.py <path_to_pickle_file_or_directory>")
        print("\nExamples:")
        print("  python analyze_memory_snapshot.py /path/to/memory_snapshot_rank0_step100.pickle")
        print("  python analyze_memory_snapshot.py /root/slime/mem_snapshots_2gpu")
        print("  python analyze_memory_snapshot.py /Users/williamren/Downloads/")
        sys.exit(1)
    
    path = sys.argv[1]
    
    if os.path.isfile(path):
        analyze_memory_snapshot(path)
    elif os.path.isdir(path):
        analyze_directory(path)
    else:
        print(f"‚ùå Path not found: {path}")
        sys.exit(1)


if __name__ == "__main__":
    main()