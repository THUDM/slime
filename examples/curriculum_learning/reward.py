from slime.rollout.rm_hub.deepscaler import get_deepscaler_rule_based_reward
from slime.utils.types import Sample


def compute_format_verify_reward(checkers, instruction, response):
    """
    Compute reward by checking if model response satisfies pre-defined format constraints.

    SECURITY NOTE: This function executes pre-defined, verified checker functions from the
    dataset. These checkers are NOT generated by the model or user at runtime.

    Safety guarantees:
    - All checker functions are pre-defined, verified, and sourced from trusted datasets
    - Checkers follow a strict format: they only accept string inputs and return boolean values
    - The execution environment is sandboxed with minimal imports (only 're' module allowed)
    - No model-generated or user-generated code is ever executed
    - Only model-generated content (strings) is passed as INPUT to these pre-verified checkers

    Checker format (all checkers follow this pattern):
        ```python
        import re
        def check_following(instruction, response):
            # Use regex to verify string format constraints
            # Example: check word length, sentence structure, etc.
            return True  # or False
        ```

    Args:
        checkers: List of pre-defined checker function source code strings from dataset
        instruction: The instruction prompt (string input to checker)
        response: The model-generated response (string input to checker)

    Returns:
        Float between 0.0 and 1.0 representing the fraction of satisfied constraints
    """
    if not checkers:
        return 0.0

    satisfied = 0
    for checker_src in checkers:
        try:
            local_ns = {}
            # Sandboxed execution: only 're' module is available, no other imports
            exec(checker_src, {"re": __import__("re")}, local_ns)
            if local_ns["check_following"](instruction, response):
                satisfied += 1
        except Exception:
            pass

    return satisfied / len(checkers)


async def async_rm_math_if(args, sample: Sample):

    metadata = sample.metadata if isinstance(sample.metadata, dict) else {}
    rm_type = (metadata.get("rm_type") or args.rm_type or "").strip()
    response = sample.response
    label = sample.label

    if rm_type == "deepscaler":
        return get_deepscaler_rule_based_reward(response, label)

    elif rm_type == "format_verify":
        # Load pre-defined checker functions from dataset metadata
        # These are verified, dataset-provided checkers (not model/user generated)
        functions = metadata.get("functions", [])
        # Extract content after </think> tag if present, otherwise use entire response
        # split('</think>')[-1] returns the last part after the tag, or the whole string if tag is absent
        reward_value = compute_format_verify_reward(
            functions,
            sample.prompt,
            response.split("</think>")[-1],
        )
        return reward_value

    elif rm_type == "ifbench":
        from slime.rollout.rm_hub.ifbench import compute_ifbench_reward

        return compute_ifbench_reward(response, label, metadata=metadata)

    else:
        raise NotImplementedError(f"Rule-based RM for {rm_type} is not implemented.")
