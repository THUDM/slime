import asyncio
import copy
from dataclasses import dataclass

from tqdm import tqdm
from transformers import AutoTokenizer

from slime.utils.async_utils import run
from slime.utils.data import JsonlDataset
from slime.utils.http_utils import get, post
from slime.utils.misc import load_function
from slime.utils.types import Sample

from .rm_hub import async_rm, batched_async_rm

__all__ = ["generate_rollout"]


@dataclass
class GenerateState:
    remaining_batch_size: int = 0
    pendings: set = None


TOKENIZER = None
SEMAPHORE = None


async def generate(args, sample: Sample, sampling_params) -> Sample:
    global TOKENIZER, SEMAPHORE
    if TOKENIZER is None:
        TOKENIZER = AutoTokenizer.from_pretrained(args.hf_checkpoint, trust_remote_code=True)

    if SEMAPHORE is None:
        SEMAPHORE = asyncio.Semaphore(
            args.sglang_server_concurrency * args.rollout_num_gpus // args.rollout_num_gpus_per_engine
        )

    url = f"http://{args.sglang_router_ip}:{args.sglang_router_port}/generate"
    payload = {
        "text": sample.prompt,
        "sampling_params": sampling_params,
    }
    while True:
        try:
            async with SEMAPHORE:
                output = await post(url, payload, use_http2=args.use_http2)
        except Exception as e:
            print(f"Error: {e}, retrying...")
            await asyncio.sleep(1)
            continue
        break

    prompt_tokens_ids = TOKENIZER(sample.prompt, add_special_tokens=False)["input_ids"]
    response_token_ids = TOKENIZER(output["text"], add_special_tokens=False)["input_ids"]

    sample.tokens = prompt_tokens_ids + response_token_ids
    sample.response_length = len(response_token_ids)
    sample.truncated = output["meta_info"]["finish_reason"]["type"] == "length"
    sample.response = output["text"]
    sample.aborted = output["meta_info"]["finish_reason"]["type"] == "abort"

    return sample


async def generate_and_rm(args, sample: Sample, sampling_params: dict, evaluation=False) -> Sample:
    # generate
    if args.custom_generate_function_path is not None:
        custom_generate_func = load_function(args.custom_generate_function_path)
        sample = await custom_generate_func(args, sample, sampling_params)
    else:
        sample = await generate(args, sample, sampling_params)

    if sample.aborted:
        return sample

    # for the rm that need the whole group, we will not do the rm here
    if args.group_rm:
        return sample

    reward = await async_rm(args, sample)
    if not evaluation and args.reward_key:
        reward = reward[args.reward_key]
    elif evaluation and args.eval_reward_key:
        reward = reward[args.eval_reward_key]
    sample.reward = reward

    return sample


async def generate_rollout_async(args, rollout_id, data_buffer) -> list[Sample]:
    """An example to implement the generate_rollout function for an rule based rm rollout generation.

    Args:
        args: the whole args
        rollout_id: int, the id of the rollout, used for deterministic data generation
        data_buffer: the data buffer to store the generated samples

    Returns:
        list[Sample]: a list of samples generated by the rollout
    """
    assert args.rollout_global_dataset

    sampling_params = dict(
        temperature=args.rollout_temperature,
        top_p=args.rollout_top_p,
        top_k=args.rollout_top_k,
        max_new_tokens=args.rollout_max_response_len,
        stop=args.rollout_stop,
        stop_token_ids=args.rollout_stop_token_ids,
        skip_special_tokens=args.rollout_skip_special_tokens,
        no_stop_trim=True,
        spaces_between_special_tokens=False,
    )

    # if over_sampling is set, the sampling batch size can be larger than
    # the required rollout batch size
    sampling_batch_size = (
        args.over_sampling_batch_size if args.over_sampling_batch_size is not None else args.rollout_batch_size
    )
    # get data from the global_dataset
    samples = await data_buffer.get_samples(sampling_batch_size * args.n_samples_per_prompt)

    state = GenerateState(
        remaining_batch_size=0,
        pendings=set(),
    )

    def submit_generate_tasks(samples):
        for sample in samples:
            state.pendings.add(
                asyncio.create_task(
                    generate_and_rm(
                        args,
                        sample,
                        sampling_params=sampling_params,
                        evaluation=False,
                    )
                )
            )
        state.remaining_batch_size += len(samples) // args.n_samples_per_prompt

    # submit the generation requests.
    submit_generate_tasks(samples)

    do_dynamic_sampling = args.over_sampling_batch_size and args.dynamic_sampling_filter_path is not None
    # load multiple time, so the filter should have no side effect, which should be rational?
    if do_dynamic_sampling:
        assert args.dynamic_sampling_filter_path is not None
        dynamic_sampling_filter = load_function(args.dynamic_sampling_filter_path)
    elif args.over_sampling_batch_size is not None:
        assert args.over_sampling_filter_path is not None
        over_sampling_filter = load_function(args.over_sampling_filter_path)

    data_group = {}
    data = []
    do_print = True

    # when doing dynamic sampling, we will use the first rollout_batch_size samples.
    target_data_size = (
        args.rollout_batch_size if do_dynamic_sampling else sampling_batch_size
    ) * args.n_samples_per_prompt
    pbar = tqdm(total=target_data_size, desc="Rollout generation")
    while len(data) < target_data_size:
        done, state.pendings = await asyncio.wait(state.pendings, return_when=asyncio.FIRST_COMPLETED)
        # Always finish all done tasks. This will make the code of partial rollout cleaner.
        # The assumption here is that group_rm is not too slow.
        for task in done:
            sample = task.result()

            # add sample to its group
            group_index = sample.index // args.n_samples_per_prompt
            if group_index not in data_group:
                data_group[group_index] = []
            data_group[group_index].append(sample)

            if do_print:
                print([sample.prompt + sample.response], flush=True)
                do_print = False

            if not len(data_group[group_index]) == args.n_samples_per_prompt:
                # wait for the data_group for this prompt finishing
                continue

            # For some rm, we need to do the rm for all samples in the group at the same time
            if args.group_rm:
                # TODO: this will stuck the asyncio loop.
                rewards = await batched_async_rm(args, data_group[group_index])
                for i, sample in enumerate(data_group[group_index]):
                    if args.reward_key:
                        sample.reward = rewards[i][args.reward_key]
                    else:
                        sample.reward = rewards[i]

            if do_dynamic_sampling:
                # the group is ready
                if dynamic_sampling_filter(args, data_group[group_index]):
                    # When having enough samples, don't add to data.
                    if len(data) == target_data_size:
                        continue
                    data.extend(data_group[group_index])
                    del data_group[group_index]
                    pbar.update(args.n_samples_per_prompt)
                else:
                    # Delete the invalid samples, don't use them in partial rollout.
                    del data_group[group_index]
                    state.remaining_batch_size -= 1
                    if state.remaining_batch_size < args.rollout_batch_size:
                        print(
                            f"Remaining batch size not enough, add {sampling_batch_size} prompts, "
                            f"sample response: {[sample.prompt + sample.response]}"
                        )
                        new_samples = await data_buffer.get_samples(sampling_batch_size * args.n_samples_per_prompt)
                        submit_generate_tasks(new_samples)
            else:
                # if not dynamic sampling, we will just add the samples to the data
                data.extend(data_group[group_index])
                pbar.update(args.n_samples_per_prompt)
                del data_group[group_index]
    pbar.close()

    print(f"Got {len(data)} samples, sample response: {[sample.prompt + sample.response]}")

    if do_dynamic_sampling:
        response = await get(
            f"http://{args.sglang_router_ip}:{args.sglang_router_port}/list_workers", use_http2=args.use_http2
        )
        for url in response["urls"]:
            # abort all the requests
            print(f"Abort request for {url}")
            await post(f"{url}/abort_request", {"rid": ""}, use_http2=False)

        while state.pendings:
            done, state.pendings = await asyncio.wait(state.pendings, return_when=asyncio.FIRST_COMPLETED)
            for task in done:
                sample = task.result()
                group_index = sample.index // args.n_samples_per_prompt
                if group_index not in data_group:
                    data_group[group_index] = []
                data_group[group_index].append(sample)

    for group_index, samples in data_group.items():
        assert (
            len(samples) == args.n_samples_per_prompt
        ), f"Got {len(samples)} samples, expected {args.n_samples_per_prompt}"
        if args.partial_rollout:
            data_buffer.add_samples(samples)

    assert len(data) == target_data_size, f"Got {len(data)} samples, expected {target_data_size}"

    if not do_dynamic_sampling and args.over_sampling_batch_size is not None:
        data = over_sampling_filter(args, data)[: args.rollout_batch_size * args.n_samples_per_prompt]
    else:
        data.sort(key=lambda sample: sample.index)

    return data


EVAL_PROMPT_DATASET = {}


async def eval_rollout(args, rollout_id):
    assert not args.group_rm, "Group RM is not supported for eval rollout"
    results = {}
    for i in range(0, len(args.eval_prompt_data), 2):
        name, path = args.eval_prompt_data[i : i + 2]
        results.update(await eval_rollout_single_dataset(args, rollout_id, name, path))
    return results


async def eval_rollout_single_dataset(args, rollout_id, name, path):
    """An example to implement the eval_rollout function for an rule based rm rollout generation.

    Args:
        args: the whole args
        rollout_id: int, the id of the rollout, used for deterministic data generation
        name: str, the name of the dataset
        path: str, the path of the dataset
    """
    assert not args.group_rm, "Group RM is not supported for eval rollout"

    global EVAL_PROMPT_DATASET

    if name not in EVAL_PROMPT_DATASET:
        tokenizer = AutoTokenizer.from_pretrained(args.hf_checkpoint, trust_remote_code=True)
        EVAL_PROMPT_DATASET[name] = JsonlDataset(
            path,
            tokenizer=tokenizer,
            max_length=args.rollout_max_prompt_len,
            prompt_key=args.input_key if args.eval_input_key is None else args.eval_input_key,
            label_key=args.label_key if args.eval_label_key is None else args.eval_label_key,
            metadata_key=args.metadata_key,
            tool_key=args.tool_key if args.eval_tool_key is None else args.eval_tool_key,
            apply_chat_template=args.apply_chat_template,
        )
    dataset = EVAL_PROMPT_DATASET[name]

    sampling_params = dict(
        temperature=args.rollout_temperature if args.eval_temperature is None else args.eval_temperature,
        top_p=args.rollout_top_p if args.eval_top_p is None else args.eval_top_p,
        top_k=args.rollout_top_k if args.eval_top_k is None else args.eval_top_k,
        max_new_tokens=(
            args.rollout_max_response_len if args.eval_max_response_len is None else args.eval_max_response_len
        ),
        stop=args.rollout_stop,
        stop_token_ids=args.rollout_stop_token_ids,
        skip_special_tokens=args.rollout_skip_special_tokens,
        no_stop_trim=True,
        spaces_between_special_tokens=False,
    )

    tasks = []
    # do multiple samples for eval prompts
    sample_index = 0
    for i, prompt_sample in enumerate(dataset.samples):
        for j in range(args.n_samples_per_eval_prompt):
            # use the same prompt for multiple samples
            sample = copy.deepcopy(prompt_sample)
            sample.index = sample_index
            sample_index += 1
            tasks.append(
                generate_and_rm(
                    args,
                    sample,
                    sampling_params=sampling_params,
                    evaluation=True,
                )
            )

    data = []
    do_print = True
    pbar = tqdm(total=len(tasks), desc="Rollout generation", disable=not do_print)
    for coro in asyncio.as_completed(tasks):
        sample = await coro
        if do_print:
            print([sample.prompt + sample.response], sample.reward)
            do_print = False
        data.append(sample)
        pbar.update(1)
    pbar.close()

    data.sort(key=lambda sample: sample.index)

    return {
        name: {
            "rewards": [sample.reward for sample in data],
            "truncated": [sample.truncated for sample in data],
        }
    }


def generate_rollout(args, rollout_id, data_buffer, evaluation=False):
    """An example to implement the generate_rollout function for an rule based rm rollout generation.

    Args:
        args: the whole args
        rollout_id: int, the id of the rollout, used for deterministic data generation
        data_buffer: the data buffer to store the generated samples
        evaluation: bool, whether the rollout is for evaluation or not

    Returns:
        list[Sample]: a list of samples generated by the rollout
    """
    assert args.rollout_global_dataset
    if evaluation:
        return run(eval_rollout(args, rollout_id))
    return run(generate_rollout_async(args, rollout_id, data_buffer))
